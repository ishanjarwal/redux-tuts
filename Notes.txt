Redux is a pattern that has a conventional use.
based on its pattern, many libraries exist.
it is independant of frameworks, but its mostly used with react
it does state management.

Global State : state at the very top of heirarchy.
Redux : helps in the access of global state


Basic Example : 
Let the balance in you bank account be the 'state'
To update this balance or 'state', you need to perform an 'action'
Let the action performed be 'deposit' amount '100'
here the type of action is 'deposit' and the 'payload' is 100.
now the bank performs some logic (balance + 100) and updates the 'state'
Similarly, other type of action can be 'withdraw' with payload say 200.
the bank performs another logic and updates the state.
another action can be to check the balance/state where no payload is required.

Here, the bank is 'Store' which stores the logics and states
The logic/function is called as the 'Reducer' which updates the state using previous state and action
Now, 'action' is just an object with type and payload, to send it to the reducer we use 'dispatch' function.
dispatch is also in the 'Store'
dispatch is event driven
Note : action is not part of the store we create it according to requirements

Setting up the project : 
create index.js file in the root
run "npm init -y" to create package.json
install redux library by running command "npm install --save redux"
change type to module to use import statements

Creating a store
import the function createStore from redux and create a const store
createStore is useless unless a reducer is passed in as a parameter
Note : createStore function is depricated instead configureStore is used

Creating a reducer 
reducer is merely a function 
it takes two parameters in the order : state and action
reducer (should) always returns a state.
for simplicity, initialize state as default argument
eg : function reducer(state={amount : 100}, action)

action are object with type and payload
action is not a part of redux, it is a convention

Sending an action with dispatch 
store.dispatch({type: 'increment'})

store.getState() method returns the global state

store.subscribe(()=>{}) calls whenever state changes
store.subscribe will call only for the dispatches after its declaration

Note : state should always be immutably changed (make a copy don't change original state)
if states are mutable, then history can't be checked

Middlewares : used between dispatch and reducer. before the dispatch is sent to the reducer, middleware can perform some actions.
applyMiddleware() method is imported and used as a second parameter in store

redux-logger is a middleware used to keep record of state changes
install it by "npm install redux-logger" and default import it
use it as applyMiddleware(logger);
if middleware error occurs then use applyMiddleware(logger.default)
middleware breaks the process into two parts, first dispatch which is done by us is used by the middleware and a new dispatch is called by the middleware for next logic processing

multiple actions can be created and dispatched by the use of switch case in reducer function

Action Creators : are functions that return an action object
hence instead of passing the action as an object, these can be called inside dispatch

Note : declare action types as constants so that they are hardcoded only once

Async Operations
install json-server globally "npm i -g json-server
create a db.json for declaration
run "json-server db.json"
this runs a fake api

Problem : if async action creator is used, it will return promise instead of object
hence a middleware should be applied so that it can wait for the api data and then pass a dispatch of object
the middleware is called redux thunk
npm install redux-thunk

working of thunk
instead of calling the action creator function, pass its definition
like : store.dispatch(initUser) 
this gives us access to "dispatch" and "getState" inside the function as parameters
async function initUser(dispatch, getState) {}
so instead of returning the state, dispatch it.
hence the process was divided into 2 : first awaiting the data and sending the final dispatch

to use variables for api calling eg accounts/2, make the async function as
function myfun(id){
    return async ()=>{
        api calling
    }
}

# Multiple Reducers
Why can't there be a single reducer but a complex state : it will be difficult to change and access state and making copies will be wrong.
use combineReducers() (from redux) to make multiple reducers 
syntax : const store = createStore(
    combineReducers({
        accounts : accountReducer,
        bonus : bonusReducer
    })
)

Now the global state has become like this : {accounts: {amount:1}, bonus: {points:1}}
but the state inside the reducer is specific

if a local state is changed based upon the decision of another global state, it is called extra reducer
eg : increment in points only when amount is > 100

In async action, there will be 3 states and 3 dispatches, pending, fullfilled and rejected