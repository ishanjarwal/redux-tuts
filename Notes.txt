# Redux Tool Kit
in this, we create slices
from createSlice() method
it takes an object
createSlice({
    name: 'reducername',
    initialState: initialState,
    reducers : {
        'action_creator' : (state, action) => {
            state.amount += 1;
        }
    }
})

note : it looks like state is changed mutably but IMMER library automatically makes a copy

then in the slice file, export 2 things
1. named export of all the action creators from slice.actions
2. default export of reducer from slice.reducer.

these can be accessed in the store 

configure the store in main.jsx

The name in createSlice is important coz it decides the name of actions and states

redux toolkit also provides two methods : createReducer and createAction
In case you don't want to use slice method, you can create and export actions and reducers with these two
syntax : 
export const increment = createAction('reward/increment');
const rewardReducer = createReducer(initState, (builder)=>{
    builder
        .addCase(increment, (state, action)=>{
            state.points++;
        })
})
export default rewardReducer

problem statement : increase bonus to 1 if amount is increase by 100 or greater
ans : use extraReducer in the slice of bonus

# async dispatches in rtk : 
createAsyncThunk() method is imported and used
syntax : const thunkname = createAsyncThunk(
    'action_name',
    async (id, thunkAPI) => {
        call the api here
    }
)

and then it is used as : thunkname(id);
it automatically creates 3 sub-actions in the following way :
thunkname.fulfilled, thunkname.pending, thunkname.rejected

* async actions are added in extraReducers always.

# RTK Query : it is only for apis
in rtk query, slice is created with createApi() method which is imported from @redux/toolkit/query/react specially for react.
createApi takes an object : which has :
    1. reducerPath : this is like the name of action in createSlice
    2. baseQuery : call the fetchBaseQuery({baseURL : 'base url of api'})
    3. endpoints that takes a builder function 
        inside this, we can create endpoints like :
                (builder) => ({
                    getAcctouns: builder.query({
                        query: () => 'accounts'
                    })
                })
 Note : the api endpoint name (getAccounts) will have an auto generated hook like 'useGetAccountQuery'
 then these hooks can be used in destructured way 
 these have predefined consts like : data, error, isLoading
 const {data, isLoading, error} = useGetAccountQuery()

 rtk-query needs a middleware to be added in order to function
 in the store, parallel to reducer, add : 
 middleware: (getDefaultMiddleware) =>{
    getDefaultMiddleware().concat(adminApi.middleware)
 }

 similarly, for requests other than get, like post, put, delete, 
 in the endpoints, builder.mutation is used
 which takes the query object and the query function should return an object like this :
 {
    url : 'account',
    method: "POST",
    body: {amount, id} // accessed from parameters
 }

 then this hook is used as : 
    const [callerfunction, response] = useAddAccountMutation();
    eg: onClick(()=>callerfunction(1, 1000))

Note : providesTags is used when data is fetched
and invalidatesTags is used when data is added
in which tag name can be anything but should be same in both

NOTE : query function takes only one parameter so if you want to send multiple paramters, then use object

transformResponse : can be used for sorting
eg : transformResponse: (response)=>response.sort((a,b)=>a.id-b.id)
